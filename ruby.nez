/*
 * Ruby 2.x
 * author : Mai MaiCuong
 *        : Masanori Sato
*/
File                                 = BRANKLINE* _ { $source(CompleteStatement) #Source }

//-----------------------------------------
EOS                                  = _ (';' / COMMENT? LINE_TERMINATOR) BRANKLINE*
SPACE                                = [\t\v\f \u00A0\uFEFF]
LINE_TERMINATOR                      = [\n\r\u2028\u2029]
BRANKLINE                            = _ COMMENT? LINE_TERMINATOR
                                     / MULTI_LINE_COMMENT LINE_TERMINATOR
COMMENT                              = '#' ( !LINE_TERMINATOR . )*
MULTI_LINE_COMMENT                   = "=begin" ( !LINE_TERMINATOR . )* LINE_TERMINATOR MULTI_LINE_COMMENT_LINES
MULTI_LINE_COMMENT_LINES             = "=end" ( !LINE_TERMINATOR . )*
                                     / ( !LINE_TERMINATOR . )* LINE_TERMINATOR MULTI_LINE_COMMENT_LINES
SP_WITH_NEWLINE                      = _ COMMENT? LINE_TERMINATOR BRANKLINE* _
                                     / SP
SP                                   = SPACE+
__                                   = SP_WITH_NEWLINE?
_                                    = SPACE*
EOF                                  = !.

//-------------------------------------------------------
/* Statement */
Block                                = DoEndBlock
                                     / BraceBlock
DoEndBlock                           = { "do" __ $param(BlockParameter)? __ $body(CompleteStatement) __ "end" #Block }
BraceBlock                           = { '{' __ $param(BlockParameter)? __ $body(CompleteStatement) __ '}' #Block }
BlockParameter                       = '||' { #Empty }
                                     / '|' __ ( BlockVar / { #Empty } ) __ '|'
BlockVar                             = MultipleLeftHandSideExpression
                                     / LeftHandSideExpression
BodyStatement                        = { addBodyStatements #Body }
addBodyStatements                    = $main(CompleteStatement) __ $rescue(RescueList)?  __ $else(ElseClause)? ( __ "ensure" __ $ensure(CompleteStatement) )?
RescueList                           = { $rescue(RescueClause) ( __ $rescue(RescueClause) )* #List }
RescueClause                         = { "rescue" ( _ $class(ExceptionClassList) )? ( _ "=>" __ $target(LeftHandSideExpression) )? _ THEN __ $then(CompleteStatement) #Rescue } // TODO check spacing
ExceptionClassList                   = OperatorExpression
                                     / MultipleRightHandSideExpression
CompleteStatement                    = { $statement(Statement) ( EOS+ _ $statement(Statement) )* EOS* _ #List }
                                     / EOS* _ { #Empty }
Statement                            = InitializerStatement
                                     / NoDecorationStatement {$body _ addDecorator }*
InitializerStatement                 = { 'BEGIN' _ '{' __ $body(CompleteStatement) __ '}' #Initializer }
addDecorator                         = "if" __ $cond(Expression) #IfDecorator
                                     / "unless" __ $cond(Expression) #UnlessDecorator
                                     / "while" __ $cond(Expression) #WhileDecorator
                                     / "until" __ $cond(Expression) #UntilDecorator
                                     / "rescue" __ $rescue(NoDecorationStatementInRescue) #RescueDecorator
NoDecorationStatement                = AliasStatement
                                     / UndefStatement
                                     / FinalizerStatement
                                     / AssignmentStatement
                                     / Expression
NoDecorationStatementInRescue        = AliasStatement
                                     / UndefStatement
                                     / FinalizerStatement
                                     / AssignmentStatement
                                     / NotExpression
AliasStatement                       = { "alias" _ $newname(MethodNameOrSymbol) _ $target(MethodNameOrSymbol) #Alias }
UndefStatement                       = { "undef" ( _ ($target(MethodNameOrSymbol)) )+ #Undef }
MethodNameOrSymbol                   = DefinedFunctionName
                                     / Symbol
FinalizerStatement                   = { 'END' _ '{' __ $body(CompleteStatement) __ '}' #Finalizer }

// Assignment and left/right hand side expression
AssignmentStatement                  = { $left(LeftHandForAssignSingle) _ '=' #Assign __ $right(CommandCallExpression / JumpExpressionWithArgs) }
                                     / { $left(LeftHandForAssignCalc) _ addAbbreviatedAssignmentOperator __ $right(CommandCallExpression / JumpExpressionWithArgs) }
                                     / { $left(LeftHandSideExpression) _ '=' __ $right(MultipleRightHandSideExpression) #ManytToOneAssign }
                                     / { $left(LHSExpandExpression) _ '=' __ $right(RightHandSideExpression) #OneToPackingAssign }
                                     / { $left(MultipleLeftHandSideExpression) _ '=' __ $right(MultipleRightHandSideExpression) #ManyToManyAssign }
                                     / { $left(MultipleLeftHandSideExpression) _ '=' __ $right(RightHandSideExpression) #ManyToManyAssign }
addAssignmentOperator                = '=' #Assign
                                     / addAbbreviatedAssignmentOperator
addAbbreviatedAssignmentOperator     = '*=' #AssignMul
                                     / '/=' #AssignDiv
                                     / '%=' #AssignMod
                                     / '**=' #AssignPower
                                     / '+=' #AssignAdd
                                     / '-=' #AssignSub
                                     / '<<=' #AssignLeftShift
                                     / '>>=' #AssignRightShift
                                     / '&=' #AssignBitwiseAnd
                                     / '^=' #AssignBitwiseXOr
                                     / '|=' #AssignBitwiseOr
                                     / '&&=' #AssignAnd
                                     / '||=' #AssignOr
LeftHandSideExpression               = { $base(PrimaryExpressionForLeftHand) addTarget }
                                     / PrimaryTarget
LeftHandForAssignSingle              = { $base(PrimaryExpressionForLeftHand) addTargetForAssignSingle }
                                     / PrimaryTarget
LeftHandForAssignCalc                = { $base(PrimaryExpressionForLeftHand) addTargetForAssignCalc }
                                     / VariableName
addTarget                            = '[' __ $index(IndexArguments)? __ ']' #Indexer
                                     / _ ('.' / '::') __ $name(Identifier) #Field
addTargetForAssignSingle             = '[' __ $index(IndexArguments)? __ ']' #Indexer
                                     / _ ('.' / '::') __ $name(LocalIdentifier) #Field
                                     / (_ '.' / '::') __ $name(ConstantIdentifier) #Field
addTargetForAssignCalc               = '[' __ $index(IndexArguments)? __ ']' #Indexer
                                     / _ '.' __ $name(Identifier) #Field
                                     / _ '::' __ $name(LocalIdentifier) #Field
PrimaryTarget                        = VariableName
                                     / ScopedConstant
MultipleLeftHandSideExpression       = GroupingLHSExpression
                                     / LHSExpandExpression
                                     / { addMultipleLHSList $item(LHSExpandExpression) #MultipleLeftHandSideExpression }
                                     / { addMultipleLHSList $item(LHSListItem)? #MultipleLeftHandSideExpression }
addMultipleLHSList                   = ( $item(LHSListItem) _ ',' __ )+
LHSListItem                          = LeftHandSideExpression
                                     / GroupingLHSExpression
LHSExpandExpression                  = { '*' $item(LeftHandSideExpression)? #Sprat }
GroupingLHSExpression                = { '(' __ $item(MultipleLeftHandSideExpression) __ ')' #Grouping }
RightHandSideExpression              = CommandCallExpression
                                     / OperatorExpression
                                     / JumpExpressionWithArgs
MultipleRightHandSideExpression      = { addOperatorExpressions ( _ ',' __ $variadic(VariadicArgument) )? #MultipleRightHandSideExpression }
                                     / { $variadic(VariadicArgument) #MultipleRightHandSideExpression }

/* Expression */
Expression                           = KeywordLogicalExpression
KeywordLogicalExpression             = NotExpression {$left _ addKeywordLogicalOperator __ $right(NotExpression) }*
addKeywordLogicalOperator            = "and" #And
                                     / "or" #Or
NotExpression                        = { "not" #Not __ $base(NotExpression) }
                                     / { "!" #Not __ $base(CommandCallExpression / JumpExpressionWithArgs) }
                                     / CommandCallExpression
                                     / OperatorExpression
                                     / JumpExpressionWithArgs
CommandCallExpression                = ChainedCommand {$base __ addChainMethdCallWithoutParentheses }?
                                     / <on !WithDoBlock Command>
JumpExpressionWithArgs               = ReturnExpressionWithArgs
                                     / BreakExpressionWithArgs
                                     / NextExpressionWithArgs
Command                              = { $base(PrimaryExpressionForCommand) _ addChainMethdCallWithoutParentheses addDoBlock }
                                     / { $(DummySelf) $name(MethodOnlyName) _ $param(ArgumentsWithoutParenetheses) addDoBlock #Applya }
                                     / { $(DummySelf) $name(Identifier) _ $param(ArgumentsWithoutParenetheses) addDoBlock #Applyb }
                                     / SuperExpressionRequireArgs
                                     / <if !WithDoBlock> YieldExpressionRequireArgs
addDoBlock                           = <if WithDoBlock> _ $body(DoEndBlock)
                                     / <if !WithDoBlock>
ChainedCommand                       = <on WithDoBlock Command> {$base __ addChainMethdCall }*
addChainMethdCall                    = ('.' / '::') __ $name(MethodName) $param(Arguments)? #Applyc
addChainMethdCallWithoutParentheses  = ('.' / '::') __ $name(MethodName) _ $param(ArgumentsWithoutParenetheses) #Applyd

OperatorExpression                   = AssignmentExpression
                                     / DefinedExpression
                                     / ConditionalExpression
addOperatorExpressions               = $expression(OperatorExpression) ( _ ',' __ $expression(OperatorExpression) )*
AssignmentExpression                 = { $left(LeftHandForAssignSingle) _ '=' #Assign __ $right(OperatorExpression) }
                                     / { $left(LeftHandForAssignCalc) _ addAbbreviatedAssignmentOperator __ $right(OperatorExpression) }
                                     / { $body({ $left(LeftHandSideExpression) _ '=' #Assign __ $right(OperatorExpression) }) _ "rescue" __ $rescure(OperatorExpression) #Rescue }
ConditionalExpression                = RangeExpression {$cond _ '?' __ $then(OperatorExpression) _ ':' __ $else(OperatorExpression) #Conditional }?
RangeExpression                      = LogicalORExpression {$ _ addRangeOperator __ $(LogicalORExpression) }*
addRangeOperator                     = '..' ('.' #OpenRange / #ClosedRange)
LogicalORExpression                  = LogicalANDExpression {$left _ '||' __ $right(LogicalANDExpression) #Or }*
LogicalANDExpression                 = EqualityExpression {$left _ '&&' __ $right(EqualityExpression) #And }*
EqualityExpression                   = RelationalExpression {$left _ addEqualityOperator __ $right(RelationalExpression) }*
addEqualityOperator                  = "==" #Equals
                                     / "!=" #NotEquals
                                     / "===" #StrictEquals
                                     / "<=>" #Compare
                                     / "=~" #Match
                                     / '!~' #NotMatch
RelationalExpression                 = BitwiseORExpression {$left _ addRelationalOperator __ $right(BitwiseORExpression) }*
addRelationalOperator                = "<=" #LessThanEquals
                                     / ">=" #GreaterThanEquals
                                     / "<" #LessThan
                                     / ">" #GreaterThan
BitwiseORExpression                  = BitwiseANDExpression {$left _ ("|" #BitwiseOr / "^" #BitwiseXor) __ $right(BitwiseANDExpression) }*
BitwiseANDExpression                 = ShiftExpression {$left _ "&" __ $right(ShiftExpression) #BitwiseAnd }*
ShiftExpression                      = AdditiveExpression {$left (_ "<<" __ #LeftShift / _ ">>" __ #RightShift) $right(AdditiveExpression) }*
AdditiveExpression                   = MultiplicativeExpression {$left _ addAdditiveOperator __ $right(MultiplicativeExpression) }*
addAdditiveOperator                  = "+" #Add
                                     / "-" #Sub
MultiplicativeExpression             = UnaryMinusExpression {$left _ addMultiplicativeOperator __ $right(UnaryMinusExpression) }*
addMultiplicativeOperator            = "*" #Mul
                                     / "%" #Mod
                                     / "/" #Div
UnaryMinusExpression                 = { "-" _ $expr(PowerExpression) #Minus }
                                     / PowerExpression
PowerExpression                      = UnaryExpression {$base _ "**" __ $power(PowerExpression) #Power }?
UnaryExpression                      = { addUnaryOperator $expr(UnaryExpression) }
                                     / PrimaryExpression
addUnaryOperator                     = "+" #Plus
                                     / "~" #Invert
                                     / "!" #Not
PrimaryExpression                    = Primary {$base addCall }*
PrimaryExpressionForLeftHand         = Primary {$base addCall &( ('[' / _ '.' / _ '::') ) }*
PrimaryExpressionForCommand          = Primary {$base addCall &( _ ('.' / '::') ) }* // TODO [ . .
PrimaryExpressionForPath             = Primary {$base addCall &( _ '::' ) }* // TODO . . ::
addCall                              = '[' __ $index(IndexArguments)? __ ']' #Indexer
                                     / _ '::' __ $name(MethodName) $param(Arguments) ( _ $body(Block) )? #Applye
                                     / _ '.' __ $name(MethodName) $param(Arguments)? ( _ $body(Block) )? #Applyf
                                     / _ '::' __ !CONSTANT $name(MethodName) ( _ $body(Block) )? #Applyg
                                     / '::' __ $name(ConstantIdentifier) #Field
Primary                              = StatementLikeExpression
                                     / <if !Nondo> PrimaryCallExpression
                                     / '(' __ Expression __ ')'
                                     / '(' __ CompleteStatement __ ')'
                                     / VariableName
                                     / PseudoVariable
                                     / ScopedConstant
                                     / ArrayLiteral
                                     / HashLiteral
                                     / Literal
                                     / HereDocument
                                     / DefinedExpressionWithParentheses

//                                   / LambdaExpression
//                                   / Variable !( _ [({] )
StatementLikeExpression              = ClassExpression
                                     / ModuleExpression
                                     / FunctionDefinition
                                     / YieldExpression
                                     / IfExpression
                                     / UnlessExpression
                                     / CaseExpression
                                     / WhileExpression
                                     / UntilExpression
                                     / ForExpression
                                     / ReturnExpression
                                     / BreakExpression
                                     / NextExpression
                                     / RedoExpression
                                     / RetryExpression
                                     / ExceptionExpression

// Conditional Expressions
DefinedExpression                    = { "defined?" __ $base(OperatorExpression) #Defined }
DefinedExpressionWithParentheses     = { "defined?" __ '(' __ $base(Expression) __ ')' #Defined }
// Control Expressions
IfExpression                         = { "if" __ $cond(Expression) _ THEN __ $then(CompleteStatement) __ $else(ElseClause / ElsifClause)? __ "end" #If }
THEN                                 = ( EOS __ )? "then"
                                     / EOS
ElsifClause                          = { "elsif" __ $cond(Expression) _ THEN __ $then(CompleteStatement) __ $else(ElseClause / ElsifClause)? #If }
ElseClause                           = "else" __ CompleteStatement
UnlessExpression                     = { "unless" __ $cond(Expression) _ THEN __ $then(CompleteStatement) __ $else(ElseClause)? __ "end" #Unless }
WhileExpression                      = { "while" __ $cond(Expression) _ DO __ $body(CompleteStatement) __ "end" #While }
DO                                   = "do"
                                     / EOS
UntilExpression                      = { "until" __ $cond(Expression) _ DO __ $body(CompleteStatement) __ "end" #Until }
ForExpression                        = { "for" __ $iter(BlockVar) _ "in" __ $range(<on Nondo Expression>) _ DO __ $body(CompleteStatement) __ "end" #For }
CaseExpression                       = { "case" __ $cond(Expression)? EOS* __ $body(CaseList) __ $else(ElseClause)? __ "end" #Case }
CaseList                             = { $when(WhenClause) ( __ $when(WhenClause) )* #List }
WhenClause                           = { "when" __ $cond(WhenArgs) _ THEN __ $then(CompleteStatement) #When }
WhenArgs                             = { addOperatorExpressions ( _ ',' __ $variadic(VariadicArgument) )? #List }
                                     / { $variadic(VariadicArgument) #List }
ExceptionExpression                  = { "begin" __ addBodyStatements __ "end" #ExceptionBlock }
PrimaryCallExpression                = { $(DummySelf) $name(MethodOnlyName) $param(Arguments)? ( _ $body(Block) )? #Applyh }
                                     / { $(DummySelf) $name(Identifier) _ $body(Block) #Applyi }
                                     / { $(DummySelf) $name(Identifier) $param(Arguments) ( _ $body(Block) )? #Applyj }
                                     / SuperExpression
DummySelf                            = { `self` #Self }
SuperExpression                      = { $(DummySelf) $super(Super) $param(Arguments)? ( _ $body(Block) )? #Applyk }
SuperExpressionRequireArgs           = { "super" _ $param(ArgumentsWithoutParenetheses) addDoBlock #Super }
Super                                = { "super" #Super }
YieldExpression                      = { "yield" ( '(' __ $param(ArgumentListWithoutProcedure) __ ')' )? #Yield }
YieldExpressionRequireArgs           = { "yield" _ !'{' $param(ArgumentListWithoutProcedure) #Yield }
ReturnExpression                     = { "return" #Return }
ReturnExpressionWithArgs             = { "return" _ $param(ArgumentListWithoutProcedure) #Return }
BreakExpression                      = { "break" #Break }
BreakExpressionWithArgs              = { "break" _ $param(ArgumentListWithoutProcedure) #Break }
NextExpression                       = { "next" #Next }
NextExpressionWithArgs               = { "next" _ $param(ArgumentListWithoutProcedure) #Next }
RedoExpression                       = { "redo"  #Redo }
RetryExpression                      = { "retry" #Retry }

// Class, Module
ClassExpression                      = { "class" __ $name(Path) ( _ "<" __ $super(SuperClass) )? EOS __ $body(BodyStatement) __ "end" #Class }
                                     / { "class" __ "<<" __ $path(Expression) EOS __ $body(BodyStatement) __ "end" #SClass } // StaticClass
Path                                 = ConstantIdentifier
                                     / ScopedConstant
                                     / { $path(PrimaryExpressionForPath) _ '::' __ $name(ConstantIdentifier) #NestedName }
SuperClass                            = Expression
ModuleExpression                     = { "module" __ $name(Path) __ $body(BodyStatement) __ "end" #Module }

// Function
FunctionDefinition                   = { "def" __ $name(DefinedFunctionName) _ $param(FunctionParameters) __ $body(BodyStatement) __ "end" #FuncDecl } // TODO avoid cannot inner func nonterminal
                                     / { "def" __ $path(TargetClass) __ ('.' / '::') __ $name(DefinedFunctionName) _ $param(FunctionParameters) __ $body(BodyStatement) __ "end" #SFuncDecl } // StaticFunction
DefinedFunctionName                  = MethodName
                                     / AssignmentLikeMethodName
FunctionParameters                   = '(' { __ addParameterList? #List } __ ')'
                                     / { addParameterList? #List } EOS
addParameterList                     = $procedure(ProcedureParameter)
                                     / $variadic(VariadicParameter) ( __ "," __ $procedure(ProcedureParameter) )?
                                     / addOptionalParameters ( __ "," __ $variadic(VariadicParameter) )? ( __ "," __ $procedure(ProcedureParameter) )?
                                     / $name(LocalIdentifier) ( __ "," __ addParameterList )?
addOptionalParameters                = $optional(OptionalParameter) ( __ "," __ $optional(OptionalParameter) )*
OptionalParameter                    = { $name(LocalIdentifier) __ "=" __ $default(OperatorExpression) #Optional }
VariadicParameter                    = { "*" ( __ $name(LocalIdentifier) )? #Variadic }
ProcedureParameter                   = { "&" __ $name(LocalIdentifier) #Procedure }
TargetClass                          = VariableName
                                     / PseudoVariable
                                     / '(' __ Expression __ ')'

// Arguments
Arguments                            = '(' __ ')'
                                     / '(' { __ $command(ChainedCommand) #List } __ ')'
                                     / '(' { __ addOperatorExpressions _ ',' __ $command(ChainedCommand) #List } __ ')'
                                     / '(' { __ addArgumentList #List } __ ')'


ArgumentsWithoutParenetheses         = !( _ '{' ) { addArgumentList #List }
addArgumentList                      = $command(<on !WithDoBlock Command>)
                                     / $procedure(ProcedureArgument)
                                     / $variadic(VariadicArgument) ( __ "," __ $procedure(ProcedureArgument) )?
                                     / addAssocs ( _ "," __ $variadic(VariadicArgument) )? ( _ "," __ $procedure(ProcedureArgument) )?
                                     / $expression(OperatorExpression) ( _ "," __ addArgumentListWithoutCommand)?
addArgumentListWithoutCommand        = $procedure(ProcedureArgument)
                                     / $variadic(VariadicArgument) ( __ "," __ $procedure(ProcedureArgument) )?
                                     / addAssocs ( _ "," __ $variadic(VariadicArgument) )? ( _ "," __ $procedure(ProcedureArgument) )?
                                     / $expression(OperatorExpression) ( _ "," __ addArgumentListWithoutCommand)?
ArgumentListWithoutProcedure         = { $command(<on !WithDoBlock Command>) #List }
                                     / { $variadic(VariadicArgument) #List }
                                     / { addAssocs ( _ "," __ $variadic(VariadicArgument) )? #List }
                                     / { $expression(OperatorExpression) ( _ "," __ addArgumentListWithoutProcCom )? #List }
addArgumentListWithoutProcCom        = $variadic(VariadicArgument)
                                     / addAssocs ( _ "," __ $variadic(VariadicArgument) )?
                                     / $expression(OperatorExpression) ( _ "," __ addArgumentListWithoutProcCom )?
VariadicArgument                     = { '*' __ $base(OperatorExpression) #Variadic }
ProcedureArgument                    = { "&" __ $base(OperatorExpression) #Procedure }
IndexArguments                       = { $command(<on !WithDoBlock Command>) #List }
                                     / { $variadic(VariadicArgument) #List }
                                     / { addAssocs ( _ "," )? #List }
                                     / { addOperatorExpressions ( _ "," __ $variadic(VariadicArgument)? )? #List }

/* Literal */
Literal                              = NumericLiteral
                                     / StringLiteral
                                     / RegularExpressionLiteral
                                     / Symbol
                                     / ParcentNotation
NumericLiteral                       = HexIntegerLiteral
                                     / BinaryIntegerLiteral
                                     / FloatingPointLiteral
                                     / DecimalLiteral
                                     / OctalIntegerLiteral
HexIntegerLiteral                    = { '0' [xX] HEX+ #HexInteger }
BinaryIntegerLiteral                 = { '0' [bB] [01_]+ #BinaryInteger }
FloatingPointLiteral                 = { DECIMAL_INTEGER '.' DIGIT+ EXPONENT_PART? #Float }
                                     / { DECIMAL_INTEGER EXPONENT_PART #Float }
DECIMAL_INTEGER                      = [1-9] DIGIT*
                                     / '0'
EXPONENT_PART                        = [eE] SIGN? DIGIT*
SIGN                                 = '+'
                                     / '-'
DecimalLiteral                       = { [1-9] DIGIT* #Integer }
                                     / '0' [dD] { DIGIT+ #Integer }
OctalIntegerLiteral                  = { '0' ([oO] OCT+ / OCT*) #OctalInteger }
OCT                                  = [0-7_]
StringLiteral                        = ["] { DoubleStringCharacter* #String } ["]
                                     / ['] { SINGLE_STRING_CHARACTER* #String } [']
                                     / [`] { BACK_STRING_CHARACTER* #Command } [`]
//                                     / '?' { ('\\' ESCAPE_SEQUENCE / !( SPACE / LINE_TERMINATOR ) SOURCE) #String }
DoubleStringCharacter                = !( ["] / '\\' / LINE_TERMINATOR / '#' ) SOURCE
                                     / '\\' ESCAPE_SEQUENCE
                                     / '#' InsertExpression
InsertExpression                     = ( '$' / '@' / '@@' ) $inner(Identifier)
                                     / '{' $inner(CompleteStatement) '}'
SOURCE                               = .
ESCAPE_SEQUENCE                      = '\\'
                                     / ["'bfnrtv]
                                     / OCTA_ESCAPE_SEQUENCE
                                     / HEX_ESCAPE_SEQUENCE
                                     / UNICODE_ESCAPE_SEQUUENCE
                                     / LINE_TERMINATOR
                                     / .
OCTA_ESCAPE_SEQUENCE                 = OCT OCT OCT
HEX_ESCAPE_SEQUENCE                  = [xX] HEX HEX
UNICODE_ESCAPE_SEQUUENCE             = [uU] HEX4
SINGLE_STRING_CHARACTER              = !( ['] / '\\' / LINE_TERMINATOR ) SOURCE
                                     / '\\' ESCAPE_SEQUENCE
BACK_STRING_CHARACTER                = !( [`] / '\\' / LINE_TERMINATOR ) SOURCE
                                     / '\\' ESCAPE_SEQUENCE
RegularExpressionLiteral             = { '/' REGEX_BODY? '/' REGEX_FLAGS #RegularExp }
REGEX_BODY                           = REGEX_FIRST_CHAR REGEX_CHAR*
REGEX_FIRST_CHAR                     = REGEX_BACKSLASH_SEQUENCE
                                     / ![*\\/\x5b] REGEX_NON_TERMINATOR
                                     / REGEX_CLASS
REGEX_BACKSLASH_SEQUENCE             = '\\' REGEX_NON_TERMINATOR
REGEX_NON_TERMINATOR                 = !LINE_TERMINATOR SOURCE
REGEX_CLASS                          = '[' REGEX_CLASS_CHAR* ']'
REGEX_CLASS_CHAR                     = ![\x5d\\] REGEX_NON_TERMINATOR
                                     / REGEX_BACKSLASH_SEQUENCE
REGEX_CHAR                           = '*'
                                     / REGEX_FIRST_CHAR
REGEX_FLAGS                          = [gimsuy]*
ParcentNotation                      = { "%" [wWiI] PN_BODY #ParcentNotation }
                                     / { "%" [qQxrs]? PN_BODY #ParcentNotation }
PN_BODY                              = '(' PN_PAREN ')'
                                     / '{' PN_BRACE '}'
                                     / '[' PN_BRAKET ']'
                                     / '<' PN_ANGLE '>'
//                                   / ' ' ( !' ' . )* ' '
//                                   / ( !LINE_TERMINATOR . )*
PN_PAREN                             = ( '(' PN_PAREN ')' / ![()] . )*
PN_BRACE                             = ( '{' PN_BRACE '}' / ![{}] . )*
PN_BRAKET                            = ( '[' PN_BRAKET ']' / ![\[\]] . )*
PN_ANGLE                             = ( '<' PN_ANGLE '>' / ![<>] . )*
HereDocument                         = <block ( "<<" <symbol HD_DELIMITER> ( !LINE_TERMINATOR . )* LINE_TERMINATOR { HD_BODYLINE* #HereDocument } HD_ENDLINE )>
                                     / <block ( "<<" "-" <symbol HD_DELIMITER> ( !LINE_TERMINATOR . )* LINE_TERMINATOR { ( _ HD_BODYLINE )* #HereDocument } _ HD_ENDLINE )>
HD_DELIMITER                         = IDENTIFIER_PART+
                                     / '\'' ( !( '\'' / LINE_TERMINATOR ) . )* '\''
                                     / '"' ( !( '"' / LINE_TERMINATOR ) . )* '"'
                                     / '`' ( !( '"' / LINE_TERMINATOR ) . )* '`'
HD_BODYLINE                          = !<match HD_DELIMITER> ( !LINE_TERMINATOR . )* LINE_TERMINATOR
HD_ENDLINE                           = <match HD_DELIMITER> LINE_TERMINATOR
HD_NEWLINE                           = LINE_TERMINATOR

ArrayLiteral                         = { '[' __ $index(IndexArguments)? __ ']' #Array }
HashLiteral                          = { '{' __ ( addAssocs _ )? ","? __ '}' #List }
addAssocs                            = $hash(Association) ( _ "," __ $hash(Association) )*
Association                          = { $key(OperatorExpression) _ ( "=>" / ":" ) __ $value(OperatorExpression) #Hash }
//                                   / { $(JsonStyleAssocSymbol) _ ":" __ $(OperatorExpression) #Assign }

/////////////////////////////////////////
// ArrayLiteral                         = { '[' ( __ addArgsNoAssoc ( __ ',' __ $({ addAssocs #Hash }) )? )? __ ( ',' __ )? ']' #Array }
//                                      / { '[' ( __ $({ addAssocs #Hash }) )? __ ( ',' __ )? ']' #Array }
// addArgsNoAssoc                       = $(Arg) !( _ "=>" ) ( __ "," __ $(Arg) !( _ "=>" ) )*
// HashLiteral                          = { '{' __ ( addAssocs ( __ ',' __ )? )? __ '}' #Hash }
// LambdaExpression                     = { '->' __ addLambdaParameter __ $(LambdaBody) #Function }
// addLambdaParameter                   = '(' __ $({ addParameterList? #List }) __ ')'
//                                      / $({ addParameterList? #List })
// LambdaBody                           = DoEndBlockWithoutParameter
//                                      / BraceBlockWithoutParameter
// DoEndBlockWithoutParameter           = "do" __ CompleteStatement __ "end"
// BraceBlockWithoutParameter           = '{' __ CompleteStatement __ '}'
// Args                                 = { addArgs #List }
// addArgs                              = $(Arg) ( __ ',' __ $(Arg) )*
// Arg                                  = OperatorExpression
// JsonStyleAssocSymbol                 = { FUNCTION_NAME #Symbol }
//                                      / { VARIABLE_NAME #Symbol }
// FunctionName                         = { FUNCTION_NAME #Name }
// FUNCTION_NAME                        = IDENTIFIER "="
//                                      / IDENTIFIER [!?]?
//                                      / OPERATOR
//                                      / ('__LINE__' / '__FILE__' / 'BEGIN' / 'END') [!?]?
//                                      / KEYWORD [!?]?
// Command                              = { $(DummySelf) $name(MethodOnlyName) !'[' !OPERATOR _ addCmdArguments #Apply }
//                                      / { $(DummySelf) $name(MethodOnlyName) !'[' !OPERATOR _ addCmdArguments? #Apply }
//                                      / { $(DummySelf) $name(Identifier) !'[' !OPERATOR _ addCmdArguments #Apply }
//                                      / { $(BeforeCommandFunctionCallExpression) _ addFuncName _ addCmdArguments #Apply }
//                                      / SuperExpressionRequireArgs
//                                      / YieldExpressionRequireArgs
// addCmdArguments                      = $param(CmdArgs) ( _ $(Block) )?
//                                      / $(Block)
// CmdArgs                              = !'{' { CmdArg ( _ ',' _ CmdArg )* #List }
// CmdArg                               = !WhileExpression !IfExpression !UntilExpression !UnlessExpression $(OperatorExpression)
// BeforeCommandFunctionCallExpression  = { {$ $(AddBeforeCommandCall) }* }
// AddBeforeCommandCall                 = { '[' __ $(Args)? __ ']' #Indexer }
//                                      / { _ addFuncName (_ AddArguments / &NEXT_CALL) #Apply }
// addFuncName                          = '.' __ $(MethodOnlyName)
//                                      / '.' __ $(Identifier)
//                                      / '::' __ $(Identifier)
//                                      / ('.' / '::') __ $(FunctionName)
// AddArguments                         = '(' __ ( $(CallArgs) __ )? ')' ( __ $(Block) )?
//                                      / !'{' $(CallArgs)? ( _ $(Block) )?
//                                      / $(Block)
// CallArgs                             = CallArgsBody
// CallArgsBody                         = { $(Command) #List }
//                                      / { $(ProcedureParameter) #List }
//                                      / { $(ExpandExpression) ( __ "," __ $(ProcedureParameter) )? #List }
//                                      / { addAssocs ( __ "," __ $(ExpandExpression) )? ( __ "," __ $(ProcedureParameter) )? #List }
//                                      / { addArgsNoAssoc ( __ "," __ addAssocs )? ( __ "," __ $(ExpandExpression) )? ( __ "," __ $(ProcedureParameter) )? #List }
//                                      / Args
// UnwrapedArray                        = { add2MoreArgs #Array }
// add2MoreArgs                         = $(Arg) ( __ ',' __ $(Arg) )+

example IfExpression '''
if a > 100 && b.zero? then
  puts "a is greater than 100 and b is 0"
elsif a > 100 then
  puts "a is greater than 100 and b is not 0"
elsif a == 100 then
  puts "a is equal to 100"
else
  puts "a is smaller than 100"
end
'''

example CaseExpression '''
case banana_num
when 1 then
  puts "Price: 20"
when 2,3,4 then
  puts "Price: 40"
when 5..8 then
  puts "Price: 80"
else
  puts "Unacceptable!"
end
'''

example UnlessExpression '''
unless lang == "Ruby" then
  puts "#{lang} is not Ruby"
else
  puts "Enjoy Ruby totorial"
end
'''

example ForExpression '''
for s in lang do
  puts s
end
'''

example ForExpression '''
for i in 1..3 do
  puts i
end
'''

example ForExpression '''
for for_cnt in 1..5 do
  loop_num += 1
  next if loop_num == 2
  redo if loop_num == 4
  puts "(1) loop_num: #{loop_num}, for_count:#{for_cnt}"
  puts "(2) loop_num: #{loop_num}, for_count:#{for_cnt}"
end
'''

example Statement next if loop == 2

example WhileExpression '''
while num < 5 do
  puts "num = #{num}"
  num = num + 1
end
'''

example UntilExpression '''
until num < 3 do
  puts "num = #{num}"
  num = num - 1
end
'''

example ExceptionExpression '''
begin
  puts "a" + 4  #文字列と数値の足し算のため例外発生
rescue => ex
  print "Class: ", ex.class, "\n"
  print "Massage: ", ex.message, "\n"
  puts "Backtrace:"
  ex.backtrace.each{|trace| puts trace}
ensure
  puts "Finish"
end
'''

example ExceptionExpression '''
begin
  raise "Exception!"
rescue => ex
  print "Massage: ", ex.message, "\n"
  puts "Backtrace:"
  ex.backtrace.each{|trace| puts trace}
end
'''

example Expression 1+2
example Expression 1-2
example Expression 1*2
example Expression 1/2
example Expression 1%2
example Expression 1+2-3*4/5
example Expression a < b
example Expression a > b
example Expression a <= b
example Expression a >= b
example Expression a == b
example Expression a === b
example Expression a != b
example Expression a <=> b
example Expression a =~ b
example Expression a !~ b
example Expression +a
example Expression -a
example Expression !a
example Expression a || b
example Expression a && b
example Expression a | b
example Expression a & b
example Expression a ^ b
example Expression a >> b
example Expression a << b

example Expression print a
example Expression print a, b, c
example PrimaryExpression print(a)
example PrimaryExpression print(a, b, c)
example Expression a[0]

example Expression add_column_options!(change_column_sql, options.merge(column: column))
example Statement return false if blob_or_text_column?
example Statement return false unless name.present?
example Statement return true if tables(nil, nil, name).any?
example Expression @visitor = Arel::Visitors::MySQL.new self
example Expression { default: 'ALGORITHM = DEFAULT', copy: 'ALGORITHM = COPY', inplace: 'ALGORITHM = INPLACE' }
example LeftHandForAssignCalc @quoted_column_names[name]
example addTargetForAssignCalc [name]
example IndexArguments name
example Statement each_hash(result) do |row|
example CompleteStatement ActionView::Base.field_error_proc = old_proc if old_proc
example NoDecorationStatement ActionView::Base.field_error_proc = old_proc if old_proc
example Expression respond_to?(generate_method, true)
example Expression !match_attribute_method?(method.to_s).nil?
example CompleteStatement !match_attribute_method?(method.to_s).nil?
example FunctionDefinition '''
  def test_field_error_proc
  ensure
    ActionView::Base.field_error_proc = old_proc if old_proc
  end
'''
example DefinedFunctionName '''
  test_field_error_proc
  ensure
    ActionView::Base.field_error_proc = old_proc if old_proc
'''
example FunctionParameters '''
  ensure
    ActionView::Base.field_error_proc = old_proc if old_proc
'''
example BodyStatement '''
  ensure
    ActionView::Base.field_error_proc = old_proc if old_proc
'''
example CompleteStatement '''
  test "serializes #{arg.class} verbatim" do
    aAssert_arguments_unchanged arg
  end
'''
example CompleteStatement '''
cp1, cp2 = database.codepoints[codepoints[pos]], database.codepoints[codepoints[pos+1]]
if (cp1.combining_class > cp2.combining_class) && (cp2.combining_class > 0)
  codepoints[pos..pos+1] = cp2.code, cp1.code
  pos += (pos > 0 ? -1 : 1)
else
  pos += 1
end
'''
example WhileExpression '''
while pos < length do
  cp1, cp2 = database.codepoints[codepoints[pos]], database.codepoints[codepoints[pos+1]]
  if (cp1.combining_class > cp2.combining_class) && (cp2.combining_class > 0)
    codepoints[pos..pos+1] = cp2.code, cp1.code
    pos += (pos > 0 ? -1 : 1)
  else
    pos += 1
  end
end
'''
example WhileExpression '''
while pos < length do
  pos += 1
end
'''
example Expression '''
pos < length
'''
/* Identifier */
Identifier                           = { IDENTIFIER #Name }
IDENTIFIER                           = !KEYWORD IDENTIFIER_START IDENTIFIER_PART*
IDENTIFIER_START                     = [a-zA-Z_]
IDENTIFIER_PART                      = IDENTIFIER_START
                                     / DIGIT
DIGIT                                = [0-9_]
LocalIdentifier                      = { LOCALIDENTIFIER #Name }
LOCALIDENTIFIER                      = !KEYWORD LOCALIDENTIFIER_START IDENTIFIER_PART*
LOCALIDENTIFIER_START                = [a-z_]

VariableName                         = { VARIABLE_IDENTIFIER #Name }
VARIABLE_IDENTIFIER                  = !KEYWORD ( '$' / '@@' / '@' )? IDENTIFIER_START IDENTIFIER_PART* ![!?]
PseudoVariable                       = SelfExpression
                                     / NilExpression
                                     / TrueExpression
                                     / FalseExpression
                                     / EncodingExpression
                                     / FileExpression
                                     / LineExpression
SelfExpression                       = { "self" ![!?] #Self }
TrueExpression                       = { "true" ![!?] #True }
FalseExpression                      = { "false" ![!?] #False }
NilExpression                        = { "nil" ![!?] #Nil }
EncodingExpression                   = { '__ENCODING__' ![!?] #Encoding }
FileExpression                       = { '__FILE__' ![!?] #File }
LineExpression                       = { '__LINE__' ![!?] #Line }

SCOPED_CONSTANT                      = '::' __ CONSTANT
ScopedConstant                       = '::' __ { CONSTANT #Name }
CONSTANT                             = !KEYWORD [A-Z] IDENTIFIER_PART* ![!?]
ConstantIdentifier                   = { CONSTANT #Name }

MethodOnlyName                       = { METHOD_ONLY_IDENTIFIER #Name }
METHOD_ONLY_IDENTIFIER               = IDENTIFIER_START IDENTIFIER_PART* [!?]
MethodName                           = { METHOD_NAME #Name }
METHOD_NAME                          = OPERATOR
                                     / KEYWORD
                                     / METHOD_ONLY_IDENTIFIER
                                     / IDENTIFIER
AssignmentLikeMethodName             = { ASSIGNMENT_LIKE_METHOD_IDENTIFIER #Name }
ASSIGNMENT_LIKE_METHOD_IDENTIFIER    = IDENTIFIER '='

Symbol                               = ':' _ { SYMBOL_NAME #Name }
SYMBOL_NAME                          = OPERATOR
                                     / KEYWORD
                                     / ASSIGNMENT_LIKE_METHOD_IDENTIFIER
                                     / METHOD_ONLY_IDENTIFIER
                                     / VARIABLE_IDENTIFIER

OPERATOR                             = "^"
                                     / "&"
                                     / "|"
                                     / "<=>"
                                     / "=="
                                     / "==="
                                     / "=~"
                                     / ">"
                                     / ">="
                                     / "<"
                                     / "<="
                                     / "<<"
                                     / ">>"
                                     / "+"
                                     / "-"
                                     / "*"
                                     / "/"
                                     / "%"
                                     / "**"
                                     / "~"
                                     / "+@"
                                     / "-@"
                                     / "[]"
                                     / "[]="
                                     / "`"

KEYWORD                              = "alias"
                                     / "and"
                                     / "begin"
                                     / "break"
                                     / "case"
                                     / "class"
                                     / "def"
                                     / "defined?"
                                     / "do"
                                     / "else"
                                     / "elsif"
                                     / "end"
                                     / "ensure"
                                     / "for"
                                     / "false"
                                     / "if"
                                     / "in"
                                     / "module"
                                     / "next"
                                     / "nil"
                                     / "not"
                                     / "or"
                                     / "redo"
                                     / "rescue"
                                     / "retry"
                                     / "return"
                                     / "self"
                                     / "super"
                                     / "then"
                                     / "true"
                                     / "undef"
                                     / "unless"
                                     / "until"
                                     / "when"
                                     / "while"
                                     / "yield"
                                     / 'BEGIN'
                                     / 'END'
                                     / '__LINE__'
                                     / '__ENCODING__'
                                     / '__FILE__'

W                                    = [a-zA-Z0-9_]
                                     / UCHAR
UCHAR                                = '\\u' HEX4
                                     / '\\U' HEX4 HEX4
HEX4                                 = HEX HEX HEX HEX
HEX                                  = [0-9a-fA-F_]
"&"                                  = '&' ![&=]
"&&"                                 = '&&' ![=]
"*"                                  = '*' ![*=]
"+"                                  = '+' ![+=@]
"-"                                  = '-' !( '-' / [=>@] )
"!"                                  = '!' ![=~]
":"                                  = ':' ![>:]
"/"                                  = '/' !'='
"%"                                  = '%' ![=>]
"<<"                                 = '<<' !'='
">>"                                 = '>>' ![=>]
"<"                                  = '<' ![<=]
">"                                  = '>' ![=>]
"=="                                 = '==' ![=]
"!="                                 = '!='
"!~"                                 = '!~'
"^"                                  = '^' ![=]
"|"                                  = '|' ![|=]
"||"                                 = '||' ![=]
"="                                  = '=' ![=>~]
"<=>"                                = '<=>'
"==="                                = '==='
"=~"                                 = '=~'
">="                                 = '>='
"<="                                 = '<='
"**"                                 = '**'
"~"                                  = '~'
"`"                                  = '`'
"+@"                                 = '+@'
"-@"                                 = '-@'
"[]"                                 = '[]' ![=]
"[]="                                = '[]='
"("                                  = '('
"=>"                                 = '=>'
"."                                  = '.'
","                                  = ','
"&&="                                = '&&='
"||="                                = '||='
"^="                                 = '^='
"&="                                 = '&='
"|="                                 = '|='
"<<="                                = '<<='
">>="                                = '>>='
"+="                                 = '+='
"-="                                 = '-='
"*="                                 = '*='
"/="                                 = '/='
"%="                                 = '%='
"**="                                = '**='
"=begin"                             = '=begin' !W
"=end"                               = '=end' !W
"do"                                 = 'do' !W
"end"                                = 'end' !W
"return"                             = 'return' !W
"yield"                              = 'yield' !W
"defined?"                           = 'defined?' !W
"if"                                 = 'if' !W
"elsif"                              = 'elsif' !W
"else"                               = 'else' !W
"unless"                             = 'unless' !W
"while"                              = 'while' !W
"until"                              = 'until' !W
"case"                               = 'case' !W
"when"                               = 'when' !W
"break"                              = 'break' !W
"next"                               = 'next' !W
"redo"                               = 'redo' !W
"for"                                = 'for' !W
"in"                                 = 'in' !W
"begin"                              = 'begin' !W
"rescue"                             = 'rescue' !W
"retry"                              = 'retry' !W
"ensure"                             = 'ensure' !W
"class"                              = 'class' !W
"module"                             = 'module' !W
"def"                                = 'def' !W
"alias"                              = 'alias' !W
"and"                                = 'and' !W
"false"                              = 'false' !W
"nil"                                = 'nil' !W
"not"                                = 'not' !W
"or"                                 = 'or' !W
"self"                               = 'self' !W
"super"                              = 'super' !W
"then"                               = 'then' !W
"true"                               = 'true' !W
"undef"                              = 'undef' !W

// formatted by $ nez format
