/*
 * Ruby 2.x
 * author : Mai MaiCuong
*/
File                                 = BRANKLINE* _ { $(CompleteStatement) #Source }

//-----------------------------------------
EOS                                  = _ (';' / COMMENT? LINE_TERMINATOR) BRANKLINE*
SPACE                                = [\t\v\f \u00A0\uFEFF]
LINE_TERMINATOR                      = [\n\r\u2028\u2029]
BRANKLINE                            = _ COMMENT? LINE_TERMINATOR
                                     / MULTI_LINE_COMMENT LINE_TERMINATOR
COMMENT                              = '#' ( !LINE_TERMINATOR . )*
MULTI_LINE_COMMENT                   = "=begin" ( !LINE_TERMINATOR . )* LINE_TERMINATOR MULTI_LINE_COMMENT_LINES
MULTI_LINE_COMMENT_LINES             = "=end" ( !LINE_TERMINATOR . )*
                                     / ( !LINE_TERMINATOR . )* LINE_TERMINATOR MULTI_LINE_COMMENT_LINES
SP_WITH_NEWLINE                      = _ COMMENT? LINE_TERMINATOR BRANKLINE* _
                                     / SP
SP                                   = SPACE+
__                                   = SP_WITH_NEWLINE?
_                                    = SPACE*
EOF                                  = !.

//-------------------------------------------------------
/* Statement */
Block                                = DoEndBlock
                                     / BraceBlock
DoEndBlock                           = { "do" __ $(BlockParameter)? __ $(CompleteStatement) __ "end" #Block }
BraceBlock                           = { '{' __ $(BlockParameter)? __ $(CompleteStatement) __ '}' #Block }
BlockParameter                       = '||' { #Empty }
                                     / '|' __ ( BlockVar / { #Empty } ) __ '|'
BlockVar                             = MultipleLeftHandSideExpression
                                     / LeftHandSideExpression
BodyStatement                        = { addBodyStatements #Begin }
addBodyStatements                    = $(CompleteStatement) __ $(RescueList)?  __ $(ElseClause)? ( __ "ensure" __ $(CompleteStatement) )?
RescueList                           = { $(RescueClause) ( __ $(RescueClause) )* #List }
RescueClause                         = { "rescue" ( _ $(ExceptionClassList) )? ( _ "=>" __ $(LeftHandSideExpression) )? _ THEN __ $(CompleteStatement) #Rescue }
ExceptionClassList                   = OperatorExpression
                                     / MultipleRightHandSideExpression
CompleteStatement                    = { $(Statement) ( EOS+ _ $(Statement) )* EOS* _ #BlockExpression }
                                     / EOS* _ { #Empty }
Statement                            = InitializerStatement
//                                   / '{' __ CompleteStatement __ '}'
                                     / <on !InRescue NoDecorationStatement> {$ _ addDecorator }*
InitializerStatement                 = { 'BEGIN' _ '{' __ $(CompleteStatement) __ '}' #Initializer }
addDecorator                         = "if" __ $(Expression) #IfDecorator
                                     / "unless" __ $(Expression) #UnlessDecorator
                                     / "while" __ $(Expression) #WhileDecorator
                                     / "until" __ $(Expression) #UntilDecorator
                                     / "rescue" __ $(<on InRescue NoDecorationStatement>) #RescueDecorator
NoDecorationStatement                = AliasStatement
                                     / UndefStatement
                                     / FinalizerStatement
                                     / AssignmentStatement
                                     / <if !InRescue> Expression
                                     / <if InRescue> KeywordNotExpression
AliasStatement                       = { "alias" _ $(FunctionNameOrSymbol) _ $(FunctionNameOrSymbol) #Alias }
UndefStatement                       = { "undef" ( _ ($(FunctionNameOrSymbol)) )+ }
FunctionNameOrSymbol                 = DefinedFunctionName
                                     / Symbol
FinalizerStatement                   = { 'END' _ '{' __ $(CompleteStatement) __ '}' #Finalizer }

// Assignment and left/right hand side expression
AssignmentStatement                  = { $left(LeftHandSideExpression) _ addAssignmentOperator __ $right(CommandCallExpression) }
                                     / { $left(LeftHandSideExpression) _ '=' __ $right(MultipleRightHandSideExpression) #ManytToOneAssign }
                                     / { $left(LHSExpandExpression) _ '=' __ $right(RightHandSideExpression) #OneToPackingAssign }
                                     / { $left(MultipleLeftHandSideExpression) _ '=' __ $right(MultipleRightHandSideExpression) #ManyToManyAssign }
                                     / { $left(MultipleLeftHandSideExpression) _ '=' __ $right(RightHandSideExpression) #ManyToManyAssign }
addAssignmentOperator                = '=' #Assign
                                     / addAbbreviatedAssignmentOperator
addAbbreviatedAssignmentOperator     = '*=' #AssignMul
                                     / '/=' #AssignDiv
                                     / '%=' #AssignMod
                                     / '**=' #AssignPower
                                     / '+=' #AssignAdd
                                     / '-=' #AssignSub
                                     / '<<=' #AssignLeftShift
                                     / '>>=' #AssignRightShift
                                     / '&=' #AssignBitwiseAnd
                                     / '^=' #AssignBitwiseXOr
                                     / '|=' #AssignBitwiseOr
                                     / '&&=' #AssignAnd
                                     / '||=' #AssignOr
LeftHandSideExpression               = PrimaryExpression {$ addCall &NEXT_CALL }* {$ addTarget }
                                     / PrimaryTarget
NEXT_CALL                            = '['
                                     / _ '.'
                                     / _ '::'
addTarget                            = '[' __ $(IndexArguments)? __ ']' #Indexer
                                     / _ ('.' / '::') __ $(Identifier) #Field
PrimaryTarget                        = VariableName
                                     / ScopedConstant
MultipleLeftHandSideExpression       = GroupingLHSExpression
                                     / LHSExpandExpression
                                     / { addMultipleLHSList $(LHSExpandExpression)? #MultipleLeftHandSideExpression }
                                     / { addMultipleLHSList $(LHSListItem)? #MultipleLeftHandSideExpression }
addMultipleLHSList                   = ( $(LHSListItem) _ ',' __ )+
LHSListItem                          = LeftHandSideExpression
                                     / GroupingLHSExpression
LHSExpandExpression                  = { '*' $(LeftHandSideExpression)? #Sprat }
GroupingLHSExpression                = { '(' __ $(MultipleLeftHandSideExpression) __ ')' #Grouping }
// GroupingLHSExpression             = '(' __ MultipleLeftHandSideExpression __ ')' //FIXME: avoid incorrect warning
RightHandSideExpression              = CommandCallExpression
                                     / OperatorExpression
MultipleRightHandSideExpression      = { addOperatorExpressions ( _ ',' __ $(SplattingArgument) )? #MultipleRightHandSideExpression }
                                     / { $(SplattingArgument) #MultipleRightHandSideExpression }

/* Expression */
Expression                           = KeywordLogicalExpression
KeywordLogicalExpression             = KeywordNotExpression {$ _ addKeywordLogicalOperator __ $(KeywordNotExpression) }*
addKeywordLogicalOperator            = "and" #And
                                     / "or" #Or
KeywordNotExpression                 = { "not" #Not __ $(KeywordNotExpression) }
                                     / { "!" #Not __ $(CommandCallExpression) }
                                     / CommandCallExpression
                                     / OperatorExpression
CommandCallExpression                = <on !WithDoBlock Command>
                                     / ChainedCommand {$ __ <on !WithParentheses addCommandCall> }?
//                                   / <on WithArgs ReturnExpression> //FIXME: conflicts with decoration statement
//                                   / <on WithArgs BreakExpression>
//                                   / <on WithArgs NextExpression>
Command                              = { $(DummySelf) $(MethodOnlyName) __ $(<on !WithParentheses Arguments>) addDoBlock #Apply }
                                     / { $(DummySelf) $(Identifier) __ $(<on !WithParentheses Arguments>) addDoBlock #Apply }
                                     / PrimaryExpression {$ addCall &( _ ('.' / '::') ) }* {$ <on !WithParentheses addCommandCall> addDoBlock }
                                     / <on RequireArgs SuperExpression>
                                     / <if !WithDoBlock> <on RequireArgs YieldExpression>
addDoBlock                           = <if WithDoBlock> __ $(DoEndBlock)
                                     / <if !WithDoBlock>
ChainedCommand                       = <on WithDoBlock Command> {$ <on WithParentheses addCommandCall> }*
addCommandCall                       = <if WithParentheses> __ ('.' / '::') __ $(MethodName) $(<on WithParentheses Arguments>)? #Apply
                                     / <if !WithParentheses> _ ('.' / '::') __ $(MethodName) __ $(<on !WithParentheses Arguments>) #Apply

OperatorExpression                   = AssignmentExpression
                                     / DefinedExpression
                                     / ConditionalExpression
addOperatorExpressions               = $(OperatorExpression) ( _ ',' __ $(OperatorExpression) )*
AssignmentExpression                 = { $left(LeftHandSideExpression) _ addAbbreviatedAssignmentOperator __ $right(OperatorExpression) }
                                     / { $left(LeftHandSideExpression) _ '=' #Assign __ $right(OperatorExpression) } {$ _ "rescue" __ $(OperatorExpression) #Rescue }?
//                                   / { $left(LeftHandSideExpression) _ addAssignmentOperator __ ($right(Command) / $right(UnwrapedArray)) }
DefinedExpression                    = { "defined?" __ $(OperatorExpression) #Defined }
ConditionalExpression                = RangeExpression {$ _ '?' __ $(OperatorExpression) __ ':' __ $(OperatorExpression) #Trinary }?
RangeExpression                      = LogicalORExpression {$ _ addRangeOperator __ $(LogicalORExpression) }*
addRangeOperator                     = '..' ('.' #OpenRange / #ClosedRange)
LogicalORExpression                  = LogicalANDExpression {$left _ '||' __ $right(LogicalANDExpression) #Or }*
LogicalANDExpression                 = EqualityExpression {$left _ '&&' __ $right(EqualityExpression) #And }*
EqualityExpression                   = RelationalExpression {$left _ addEqualityOperator __ $right(RelationalExpression) }*
addEqualityOperator                  = "==" #Equals
                                     / "!=" #NotEquals
                                     / "===" #StrictEquals
                                     / "<=>" #Compare
                                     / "=~" #Match
                                     / '!~' #NotMatch
RelationalExpression                 = BitwiseORExpression {$left _ addRelationalOperator __ $right(BitwiseORExpression) }*
addRelationalOperator                = "<=" #LessThanEquals
                                     / ">=" #GreaterThanEquals
                                     / "<" #LessThan
                                     / ">" #GreaterThan
BitwiseORExpression                  = BitwiseANDExpression {$left _ ("|" #BitwiseOr / "^" #BitwiseXor) __ $right(BitwiseANDExpression) }*
BitwiseANDExpression                 = ShiftExpression {$left _ "&" __ $right(ShiftExpression) #BitwiseAnd }*
ShiftExpression                      = AdditiveExpression {$left (_ "<<" __ #LeftShift / _ ">>" __ #RightShift) $right(AdditiveExpression) }*
AdditiveExpression                   = MultiplicativeExpression {$left _ addAdditiveOperator __ $right(MultiplicativeExpression) }*
addAdditiveOperator                  = "+" #Add
                                     / "-" #Sub
MultiplicativeExpression             = UnaryMinusExpression {$left _ addMultiplicativeOperator __ $right(UnaryMinusExpression) }*
addMultiplicativeOperator            = "*" #Mul
                                     / "%" #Mod
                                     / "/" #Div
UnaryMinusExpression                 = { "-" _ $expr(UnaryMinusExpression) #Minus }
                                     / PowerExpression
PowerExpression                      = UnaryExpression {$ _ "**" __ $(PowerExpression) #Power }?
UnaryExpression                      = { addUnaryOperator $expr(UnaryExpression) }
                                     / FunctionCallExpression
addUnaryOperator                     = "+" #Plus
                                     / "~" #Invert
                                     / "!" #Not
FunctionCallExpression               = PrimaryExpression {$ addCall }*
addCall                              = '[' __ $(IndexArguments)? __ ']' #Indexer
                                     / _ '.' __ $(MethodName) $(<on WithParentheses Arguments>)? ( __ $(Block) )? #Apply
                                     / _ '::' __ !CONSTANT $(MethodName) ( __ $(Block) )? #Apply
                                     / _ '::' __ $(MethodName) $(<on WithParentheses Arguments>) ( __ $(Block) )? #Apply
PrimaryExpression                    = '(' __ Expression __ ')'
                                     / '(' __ CompleteStatement __ ')'
                                     / Literal
                                     / HereDocument
                                     / ArrayLiteral
                                     / HashLiteral
//                                   / LambdaExpression
                                     / VariableName
                                     / PseudoVariable
//                                   / Variable !( _ [({] )
                                     / PrimaryCallExpression
                                     / <on WithParentheses DefinedExpression>
                                     / ScopedConstant
                                     / StatementLikeExpression
StatementLikeExpression              = IfExpression
                                     / UnlessExpression
                                     / WhileExpression
                                     / UntilExpression
                                     / ForExpression
                                     / CaseExpression
                                     / BeginExpression
                                     / <on !RequireArgs YieldExpression>
                                     / ReturnExpression
                                     / BreakExpression
                                     / NextExpression
//                                   / <on !WithArgs ReturnExpression> //FIXME: avoid infinite loop
//                                   / <on !WithArgs BreakExpression>
//                                   / <on !WithArgs NextExpression>
                                     / RedoExpression
                                     / RetryExpression
                                     / ClassExpression
                                     / ModuleExpression
                                     / FunctionDefinition
                                     / EigenMethodDefinition

// Conditional Expressions
DefinedExpression                    = <if WithParentheses> { "defined?" __ '(' __ $(Expression) __ ')' #Defined }
                                     / <if !WithParentheses> { "defined?" _ $(OperatorExpression) #Defined }

// Control Expressions
IfExpression                         = { "if" __ $cond(Expression) _ THEN __ $then(CompleteStatement) __ $else(ElseClause / ElsifClause)? __ "end" #If }
THEN                                 = ( EOS __ )? "then"
                                     / EOS
ElsifClause                          = { "elsif" __ $cond(Expression) _ THEN __ $then(CompleteStatement) __ $else(ElseClause / ElsifClause)? #If }
ElseClause                           = "else" __ CompleteStatement
UnlessExpression                     = { "unless" __ $cond(Expression) _ THEN __ $then(CompleteStatement) __ $else(ElseClause)? __ "end" #Unless }
WhileExpression                      = { "while" __ $cond(Expression) _ DO __ $body(CompleteStatement) __ "end" #While }
DO                                   = "do"
                                     / EOS
UntilExpression                      = { "until" __ $(Expression) _ DO __ $(CompleteStatement) __ "end" #Until }
ForExpression                        = { "for" __ $(BlockVar) _ "in" __ $(Expression) _ DO __ $(CompleteStatement) __ "end" #For }
CaseExpression                       = { "case" __ $(Expression) EOS? __ $(CaseList) __ $else(ElseClause)? __ "end" #Case }
                                     / { "case" EOS? __ $(CaseList) __ $else(ElseClause)? __ "end" #Case }
CaseList                             = { $(WhenClause) ( __ $(WhenClause) )* #List }
WhenClause                           = { "when" __ $(WhenArgs) _ THEN __ $(CompleteStatement) #When }
WhenArgs                             = { addOperatorExpressions ( _ ',' __ $(SplattingArgument) )? #List }
                                     / { $(SplattingArgument) #List }
BeginExpression                      = { "begin" EOS* _ addBodyStatements __ "end" #Begin }
PrimaryCallExpression                = { $(DummySelf) $(MethodOnlyName) $(<on WithParentheses Arguments>)? ( __ $(Block) )? #Apply }
                                     / { $(DummySelf) $(Identifier) __ $(Block) #Apply }
                                     / { $(DummySelf) $(Identifier) $(<on WithParentheses Arguments>) ( __ $(Block) )? #Apply }
                                     / <on !RequireArgs SuperExpression>
DummySelf                            = { `self` #Self }
SuperExpression                      = <if RequireArgs> { "super" __ $(<on !WithParentheses Arguments>) addDoBlock #Super }
                                     / <if !RequireArgs> { $(DummySelf) $(Super) $(<on WithParentheses Arguments>)? ( __ $(Block) )? #Apply }
Super                                = { "super" #Super }
YieldExpression                      = <if RequireArgs> { "yield" __ $(<on !WithParentheses Arguments>) #Redo }
                                     / <if !RequireArgs> { "yield" ( __ '(' __ $({ addArgumentList? #List }) __ ')' )? #Redo }
ReturnExpression                     = { "return" #Return }
BreakExpression                      = { "break" #Break }
NextExpression                       = { "next" #Next }
// ReturnExpression                  = <if WithArgs> { "return" _ addArgumentList #Return } //FIXME: avoid infinite loop
//                                   / <if !WithArgs> { "return" #Return }
// BreakExpression                   = <if WithArgs> { "break" _ addArgumentList #Break }
//                                   / <if !WithArgs> { "break" #Break }
// NextExpression                    = <if WithArgs> { "next" _ addArgumentList #Next }
//                                   / <if !WithArgs> { "next" #Next }
RedoExpression                       = { "redo"  #Redo }
RetryExpression                      = { "retry" #Retry }

// Class, Module
ClassExpression                      = { "class" __ $(Path) ( _ "<" __ $(BaseClass) )? EOS __ $(BodyStatement) __ "end" #Class }
                                     / { "class" __ "<<" __ $(Expression) EOS __ $(BodyStatement) __ "end" #SingletonClass }
Path                                 = Identifier
                                     / ScopedConstant
                                     / { $(PrimaryExpression) _ '::' __ $(Identifier) #Name }
BaseClass                            = Expression
ModuleExpression                     = { "module" __ $(Path) __ $(BodyStatement) __ "end" #Module }

// Function
FunctionDefinition                   = { "def" __ $name(DefinedFunctionName) _ $param(FunctionParameters) __ $body(BodyStatement) __ "end" #FuncDecl }
DefinedFunctionName                  = MethodName
                                     / AssignmentLikeMethodName
FunctionParameters                   = '(' __ { addParameterList? #List } __ ')' EOS?
                                     / { addParameterList? #List } EOS
addParameterList                     = $(ProcessParameter)
                                     / $(VariadicParameter) ( __ "," __ $(ProcessParameter) )?
                                     / addParameterAssocs ( __ "," __ $(VariadicParameter) )? ( __ "," __ $(ProcessParameter) )?
                                     / addParameters ( __ "," __ addParameterAssocs )? ( __ "," __ $(VariadicParameter) )? ( __ "," __ $(ProcessParameter) )?
addParameters                        = $(Identifier) !( _ "=" ) ( __ "," __ $(Identifier) !( _ "=" ) )*
addParameterAssocs                   = $(DefaultValueAssociation) ( __ "," __ $(DefaultValueAssociation) )*
DefaultValueAssociation              = { $(Identifier) __ "=" __ $(OperatorExpression) #Assign }
VariadicParameter                    = { "*" ( __ $(Identifier) )? #VariadicParameter }
ProcessParameter                     = { "&" __ $(Identifier) #ProcessParameter }
//                                   / { "&" __ $(Symbol) #ProcessParameter }
EigenMethodDefinition                = { "def" __ $(Singleton) __ ('.' / '::') __ $(DefinedFunctionName) _ $param(FunctionParameters) __ $(BodyStatement) __ "end" #EigenFunction }
Singleton                            = VariableName
                                     / PseudoVariable
                                     / '(' __ Expression __ ')'

// Arguments
Arguments                            = <if WithParentheses> '(' __ ')'
                                     / <if WithParentheses> '(' __ { addArgumentList #List } __ ')'
                                     / <if WithParentheses> '(' __ { $(ChainedCommand) #List } __ ')'
                                     / <if WithParentheses> '(' __ { addOperatorExpressions _ ',' __ $(ChainedCommand) #List } __ ')'
                                     / <if !WithParentheses> !( _ '{' ) { addArgumentList #List }
addArgumentList                      = $(<on !WithDoBlock Command>)
                                     / $(BlockArgument)
                                     / $(SplattingArgument) ( __ "," __ $(BlockArgument) )?
                                     / addAssocs ( _ "," __ $(SplattingArgument) )? ( _ "," __ $(BlockArgument) )?
                                     / addOperatorExpressions ( _ "," __ addAssocs)? ( _ "," __ $(SplattingArgument) )? ( _ "," __ $(BlockArgument) )?
SplattingArgument                    = { '*' __ $(OperatorExpression) #Splat }
BlockArgument                        = { "&" __ $(OperatorExpression) #BlockArgument }
IndexArguments                       = { $(<on !WithDoBlock Command>) #List }
                                     / { $(SplattingArgument) #List }
                                     / { addAssocs ( _ "," )? #List }
                                     / { addOperatorExpressions ( _ "," __ $(SplattingArgument)? )? #List }

/* Literal */
Literal                              = NumericLiteral
                                     / StringLiteral
                                     / RegularExpressionLiteral
                                     / Symbol
                                     / ParcentNotation
NumericLiteral                       = HexIntegerLiteral
                                     / BinaryIntegerLiteral
                                     / FloatingPointLiteral
                                     / DecimalLiteral
                                     / OctalIntegerLiteral
HexIntegerLiteral                    = { '0' [xX] HEX+ #HexInteger }
BinaryIntegerLiteral                 = { '0' [bB] [01_]+ #BinaryInteger }
FloatingPointLiteral                 = { DECIMAL_INTEGER '.' DIGIT+ EXPONENT_PART? #Float }
                                     / { DECIMAL_INTEGER EXPONENT_PART #Float }
DECIMAL_INTEGER                      = [1-9] DIGIT*
                                     / '0'
EXPONENT_PART                        = [eE] SIGN? DIGIT*
SIGN                                 = '+'
                                     / '-'
DecimalLiteral                       = { [1-9] DIGIT* #Integer }
                                     / '0' [dD] { DIGIT+ #Integer }
OctalIntegerLiteral                  = { '0' ([oO] OCT+ / OCT*) #OctalInteger }
OCT                                  = [0-7_]
StringLiteral                        = ["] { DOUBLE_STRING_CHARACTER* #String } ["]
                                     / ['] { SINGLE_STRING_CHARACTER* #String } [']
                                     / [`] { BACK_STRING_CHARACTER* #Command } [`]
                                     / '?' { ('\\' ESCAPE_SEQUENCE / !( SPACE / LINE_TERMINATOR ) SOURCE) #String }
DOUBLE_STRING_CHARACTER              = !( ["] / '\\' / LINE_TERMINATOR ) SOURCE
                                     / '\\' ESCAPE_SEQUENCE
SOURCE                               = .
ESCAPE_SEQUENCE                      = '\\'
                                     / ["'bfnrtv]
                                     / OCTA_ESCAPE_SEQUENCE
                                     / HEX_ESCAPE_SEQUENCE
                                     / UNICODE_ESCAPE_SEQUUENCE
                                     / LINE_TERMINATOR
                                     / .
OCTA_ESCAPE_SEQUENCE                 = OCT OCT OCT
HEX_ESCAPE_SEQUENCE                  = [xX] HEX HEX
UNICODE_ESCAPE_SEQUUENCE             = [uU] HEX4
SINGLE_STRING_CHARACTER              = !( ['] / '\\' / LINE_TERMINATOR ) SOURCE
                                     / '\\' ESCAPE_SEQUENCE
BACK_STRING_CHARACTER                = !( [`] / '\\' / LINE_TERMINATOR ) SOURCE
                                     / '\\' ESCAPE_SEQUENCE
RegularExpressionLiteral             = { '/' REGEX_BODY? '/' REGEX_FLAGS #RegularExp }
REGEX_BODY                           = REGEX_FIRST_CHAR REGEX_CHAR*
REGEX_FIRST_CHAR                     = REGEX_BACKSLASH_SEQUENCE
                                     / ![*\\/\x5b] REGEX_NON_TERMINATOR
                                     / REGEX_CLASS
REGEX_BACKSLASH_SEQUENCE             = '\\' REGEX_NON_TERMINATOR
REGEX_NON_TERMINATOR                 = !LINE_TERMINATOR SOURCE
REGEX_CLASS                          = '[' REGEX_CLASS_CHAR* ']'
REGEX_CLASS_CHAR                     = ![\x5d\\] REGEX_NON_TERMINATOR
                                     / REGEX_BACKSLASH_SEQUENCE
REGEX_CHAR                           = '*'
                                     / REGEX_FIRST_CHAR
REGEX_FLAGS                          = [gimsy]*
ParcentNotation                      = { "%" [wWiI] PN_BODY #ParcentNotation }
                                     / { "%" [qQxrs]? PN_BODY #ParcentNotation }
PN_BODY                              = '(' PN_PAREN ')'
                                     / '{' PN_BRACE '}'
                                     / '[' PN_BRAKET ']'
                                     / '<' PN_ANGLE '>'
//                                   / ' ' ( !' ' . )* ' '
//                                   / ( !LINE_TERMINATOR . )*
PN_PAREN                             = ( '(' PN_PAREN ')' / ![()] . )*
PN_BRACE                             = ( '{' PN_BRACE '}' / ![{}] . )*
PN_BRAKET                            = ( '[' PN_BRAKET ']' / ![\[\]] . )*
PN_ANGLE                             = ( '<' PN_ANGLE '>' / ![<>] . )*
HereDocument                         = <block ( "<<" <symbol HD_DELIMITER> ( !LINE_TERMINATOR . )* LINE_TERMINATOR { HD_BODYLINE* #HereDocument } HD_ENDLINE )>
                                     / <block ( "<<" "-" <symbol HD_DELIMITER> ( !LINE_TERMINATOR . )* LINE_TERMINATOR { ( _ HD_BODYLINE )* #HereDocument } _ HD_ENDLINE )>
HD_DELIMITER                         = IDENTIFIER_PART+
                                     / '\'' ( !( '\'' / LINE_TERMINATOR ) . )* '\''
                                     / '"' ( !( '"' / LINE_TERMINATOR ) . )* '"'
                                     / '`' ( !( '"' / LINE_TERMINATOR ) . )* '`'
HD_BODYLINE                          = !<match HD_DELIMITER> ( !LINE_TERMINATOR . )* LINE_TERMINATOR
HD_ENDLINE                           = <match HD_DELIMITER> LINE_TERMINATOR
HD_NEWLINE                           = LINE_TERMINATOR

ArrayLiteral                         = { '[' __ $(IndexArguments)? __ ']' #Array }
HashLiteral                          = { '{' __ ( addAssocs ( _ ',' __ )? )? __ '}' #Hash }
addAssocs                            = $(Association) ( _ "," __ $(Association) )*
Association                          = { $(OperatorExpression) _ "=>" __ $(OperatorExpression) #Assign }
//                                   / { $(JsonStyleAssocSymbol) _ ":" __ $(OperatorExpression) #Assign }

/////////////////////////////////////////
// ArrayLiteral                         = { '[' ( __ addArgsNoAssoc ( __ ',' __ $({ addAssocs #Hash }) )? )? __ ( ',' __ )? ']' #Array }
//                                      / { '[' ( __ $({ addAssocs #Hash }) )? __ ( ',' __ )? ']' #Array }
// addArgsNoAssoc                       = $(Arg) !( _ "=>" ) ( __ "," __ $(Arg) !( _ "=>" ) )*
// HashLiteral                          = { '{' __ ( addAssocs ( __ ',' __ )? )? __ '}' #Hash }
// LambdaExpression                     = { '->' __ addLambdaParameter __ $(LambdaBody) #Function }
// addLambdaParameter                   = '(' __ $({ addParameterList? #List }) __ ')'
//                                      / $({ addParameterList? #List })
// LambdaBody                           = DoEndBlockWithoutParameter
//                                      / BraceBlockWithoutParameter
// DoEndBlockWithoutParameter           = "do" __ CompleteStatement __ "end"
// BraceBlockWithoutParameter           = '{' __ CompleteStatement __ '}'
// Args                                 = { addArgs #List }
// addArgs                              = $(Arg) ( __ ',' __ $(Arg) )*
// Arg                                  = OperatorExpression
// JsonStyleAssocSymbol                 = { FUNCTION_NAME #Symbol }
//                                      / { VARIABLE_NAME #Symbol }
// FunctionName                         = { FUNCTION_NAME #Name }
// FUNCTION_NAME                        = IDENTIFIER "="
//                                      / IDENTIFIER [!?]?
//                                      / OPERATOR
//                                      / ('__LINE__' / '__FILE__' / 'BEGIN' / 'END') [!?]?
//                                      / KEYWORD [!?]?
// Command                              = { $(DummySelf) $name(MethodOnlyName) !'[' !OPERATOR _ addCmdArguments #Apply }
//                                      / { $(DummySelf) $name(MethodOnlyName) !'[' !OPERATOR _ addCmdArguments? #Apply }
//                                      / { $(DummySelf) $name(Identifier) !'[' !OPERATOR _ addCmdArguments #Apply }
//                                      / { $(BeforeCommandFunctionCallExpression) _ addFuncName _ addCmdArguments #Apply }
//                                      / <on RequireArgs SuperExpression>
//                                      / <on RequireArgs YieldExpression>
// addCmdArguments                      = $param(CmdArgs) ( _ $(Block) )?
//                                      / $(Block)
// CmdArgs                              = !'{' { CmdArg ( _ ',' _ CmdArg )* #List }
// CmdArg                               = !WhileExpression !IfExpression !UntilExpression !UnlessExpression $(OperatorExpression)
// BeforeCommandFunctionCallExpression  = { {$ $(AddBeforeCommandCall) }* }
// AddBeforeCommandCall                 = { '[' __ $(Args)? __ ']' #Indexer }
//                                      / { _ addFuncName (_ AddArguments / &NEXT_CALL) #Apply }
// addFuncName                          = '.' __ $(MethodOnlyName)
//                                      / '.' __ $(Identifier)
//                                      / '::' __ $(Identifier)
//                                      / ('.' / '::') __ $(FunctionName)
// AddArguments                         = '(' __ ( $(CallArgs) __ )? ')' ( __ $(Block) )?
//                                      / !'{' $(CallArgs)? ( _ $(Block) )?
//                                      / $(Block)
// CallArgs                             = CallArgsBody
// CallArgsBody                         = { $(Command) #List }
//                                      / { $(ProcessParameter) #List }
//                                      / { $(ExpandExpression) ( __ "," __ $(ProcessParameter) )? #List }
//                                      / { addAssocs ( __ "," __ $(ExpandExpression) )? ( __ "," __ $(ProcessParameter) )? #List }
//                                      / { addArgsNoAssoc ( __ "," __ addAssocs )? ( __ "," __ $(ExpandExpression) )? ( __ "," __ $(ProcessParameter) )? #List }
//                                      / Args
// UnwrapedArray                        = { add2MoreArgs #Array }
// add2MoreArgs                         = $(Arg) ( __ ',' __ $(Arg) )+

example IfExpression '''
if a > 100 && b.zero? then
  puts "a is greater than 100 and b is 0"
elsif a > 100 then
  puts "a is greater than 100 and b is not 0"
elsif a == 100 then
  puts "a is equal to 100"
else
  puts "a is smaller than 100"
end
'''

example CaseExpression '''
case banana_num
when 1 then
  puts "Price: 20"
when 2,3,4 then
  puts "Price: 40"
when 5..8 then
  puts "Price: 80"
else
  puts "Unacceptable!"
end
'''

example UnlessExpression '''
unless lang == "Ruby" then
  puts "#{lang} is not Ruby"
else
  puts "Enjoy Ruby totorial"
end
'''

example ForExpression '''
for s in lang do
  puts s
end
'''

example ForExpression '''
for i in 1..3 do
  puts i
end
'''

example ForExpression '''
for for_cnt in 1..5 do
  loop_num += 1
  next if loop_num == 2
  redo if loop_num == 4
  puts "(1) loop_num: #{loop_num}, for_count:#{for_cnt}"
  puts "(2) loop_num: #{loop_num}, for_count:#{for_cnt}"
end
'''

example WhileExpression '''
while num < 5 do
  puts "num = #{num}"
  num = num + 1
end
'''

example UntilExpression '''
until num < 3 do
  puts "num = #{num}"
  num = num - 1
end
'''

example BeginExpression '''
begin
  puts "a" + 4  #文字列と数値の足し算のため例外発生
rescue => ex
  print "Class: ", ex.class, "\n"
  print "Massage: ", ex.message, "\n"
  puts "Backtrace:"
  ex.backtrace.each{|trace| puts trace}
ensure
  puts "Finish"
end
'''

example BeginExpression '''
begin
  raise "Exception!"
rescue => ex
  print "Massage: ", ex.message, "\n"
  puts "Backtrace:"
  ex.backtrace.each{|trace| puts trace}
end
'''

example Expression 1+2
example Expression 1-2
example Expression 1*2
example Expression 1/2
example Expression 1%2
example Expression 1+2-3*4/5
example Expression a < b
example Expression a > b
example Expression a <= b
example Expression a >= b
example Expression a == b
example Expression a === b
example Expression a != b
example Expression a <=> b
example Expression a =~ b
example Expression a !~ b
example Expression +a
example Expression -a
example Expression !a
example Expression a || b
example Expression a && b
example Expression a | b
example Expression a & b
example Expression a ^ b
example Expression a >> b
example Expression a << b

example Expression print a
example Expression print a, b, c
example FunctionCallExpression print(a)
example FunctionCallExpression print(a, b, c)
example Expression a[0]

/* Identifier */
Identifier                           = { IDENTIFIER #Name }
IDENTIFIER                           = !KEYWORD IDENTIFIER_START IDENTIFIER_PART*
IDENTIFIER_START                     = [a-zA-Z_]
IDENTIFIER_PART                      = IDENTIFIER_START
                                     / DIGIT
DIGIT                                = [0-9_]

VariableName                         = { VARIABLE_IDENTIFIER #Name }
VARIABLE_IDENTIFIER                  = !KEYWORD ( '$' / '@@' / '@' )? IDENTIFIER_START IDENTIFIER_PART* ![!?]
PseudoVariable                       = SelfExpression
                                     / NilExpression
                                     / TrueExpression
                                     / FalseExpression
                                     / EncodingExpression
                                     / FileExpression
                                     / LineExpression
SelfExpression                       = { "self" ![!?] #Self }
TrueExpression                       = { "true" ![!?] #True }
FalseExpression                      = { "false" ![!?] #False }
NilExpression                        = { "nil" ![!?] #Nil }
EncodingExpression                   = { '__ENCODING__' ![!?] #Encoding }
FileExpression                       = { '__FILE__' ![!?] #File }
LineExpression                       = { '__LINE__' ![!?] #Line }

SCOPED_CONSTANT                      = '::' __ CONSTANT
ScopedConstant                       = '::' __ { CONSTANT #Name }
CONSTANT                             = !KEYWORD [A-Z] IDENTIFIER_PART* ![!?]

MethodOnlyName                       = { METHOD_ONLY_IDENTIFIER #Name }
METHOD_ONLY_IDENTIFIER               = IDENTIFIER_START IDENTIFIER_PART* [!?]
MethodName                           = { METHOD_NAME #Name }
METHOD_NAME                          = OPERATOR
                                     / KEYWORD
                                     / METHOD_ONLY_IDENTIFIER
                                     / IDENTIFIER
AssignmentLikeMethodName             = { ASSIGNMENT_LIKE_METHOD_IDENTIFIER #Name }
ASSIGNMENT_LIKE_METHOD_IDENTIFIER    = IDENTIFIER '='

Symbol                               = ':' _ { SYMBOL_NAME #Name }
SYMBOL_NAME                          = OPERATOR
                                     / KEYWORD
                                     / ASSIGNMENT_LIKE_METHOD_IDENTIFIER
                                     / METHOD_ONLY_IDENTIFIER
                                     / VARIABLE_IDENTIFIER

OPERATOR                             = "^"
                                     / "&"
                                     / "|"
                                     / "<=>"
                                     / "=="
                                     / "==="
                                     / "=~"
                                     / ">"
                                     / ">="
                                     / "<"
                                     / "<="
                                     / "<<"
                                     / ">>"
                                     / "+"
                                     / "-"
                                     / "*"
                                     / "/"
                                     / "%"
                                     / "**"
                                     / "~"
                                     / "+@"
                                     / "-@"
                                     / "[]"
                                     / "[]="
                                     / "`"

KEYWORD                              = "alias"
                                     / "and"
                                     / "begin"
                                     / "break"
                                     / "case"
                                     / "class"
                                     / "def"
                                     / "defined?"
                                     / "do"
                                     / "else"
                                     / "elsif"
                                     / "end"
                                     / "ensure"
                                     / "for"
                                     / "false"
                                     / "if"
                                     / "in"
                                     / "module"
                                     / "next"
                                     / "nil"
                                     / "not"
                                     / "or"
                                     / "redo"
                                     / "rescue"
                                     / "retry"
                                     / "return"
                                     / "self"
                                     / "super"
                                     / "then"
                                     / "true"
                                     / "undef"
                                     / "unless"
                                     / "until"
                                     / "when"
                                     / "while"
                                     / "yield"
                                     / 'BEGIN'
                                     / 'END'
                                     / '__LINE__'
                                     / '__ENCODING__'
                                     / '__FILE__'

W                                    = [a-zA-Z0-9_]
                                     / UCHAR
UCHAR                                = '\\u' HEX4
                                     / '\\U' HEX4 HEX4
HEX4                                 = HEX HEX HEX HEX
HEX                                  = [0-9a-fA-F_]
"&"                                  = '&' ![&=]
"&&"                                 = '&&' ![=]
"*"                                  = '*' ![*=]
"+"                                  = '+' ![+=@]
"-"                                  = '-' !( '-' / [=>@] )
"!"                                  = '!' ![=~]
":"                                  = ':' ![>:]
"/"                                  = '/' !'='
"%"                                  = '%' ![=>]
"<<"                                 = '<<' !'='
">>"                                 = '>>' ![=>]
"<"                                  = '<' ![<=]
">"                                  = '>' ![=>]
"=="                                 = '==' ![=]
"!="                                 = '!='
"!~"                                 = '!~'
"^"                                  = '^' ![=]
"|"                                  = '|' ![|=]
"||"                                 = '||' ![=]
"="                                  = '=' ![=>~]
"<=>"                                = '<=>'
"==="                                = '==='
"=~"                                 = '=~'
">="                                 = '>='
"<="                                 = '<='
"**"                                 = '**'
"~"                                  = '~'
"`"                                  = '`'
"+@"                                 = '+@'
"-@"                                 = '-@'
"[]"                                 = '[]' ![=]
"[]="                                = '[]='
"("                                  = '('
"=>"                                 = '=>'
"."                                  = '.'
","                                  = ','
"&&="                                = '&&='
"||="                                = '||='
"^="                                 = '^='
"&="                                 = '&='
"|="                                 = '|='
"<<="                                = '<<='
">>="                                = '>>='
"+="                                 = '+='
"-="                                 = '-='
"*="                                 = '*='
"/="                                 = '/='
"%="                                 = '%='
"**="                                = '**='
"=begin"                             = '=begin' !W
"=end"                               = '=end' !W
"do"                                 = 'do' !W
"end"                                = 'end' !W
"return"                             = 'return' !W
"yield"                              = 'yield' !W
"defined?"                           = 'defined?' !W
"if"                                 = 'if' !W
"elsif"                              = 'elsif' !W
"else"                               = 'else' !W
"unless"                             = 'unless' !W
"while"                              = 'while' !W
"until"                              = 'until' !W
"case"                               = 'case' !W
"when"                               = 'when' !W
"break"                              = 'break' !W
"next"                               = 'next' !W
"redo"                               = 'redo' !W
"for"                                = 'for' !W
"in"                                 = 'in' !W
"begin"                              = 'begin' !W
"rescue"                             = 'rescue' !W
"retry"                              = 'retry' !W
"ensure"                             = 'ensure' !W
"class"                              = 'class' !W
"module"                             = 'module' !W
"def"                                = 'def' !W
"alias"                              = 'alias' !W
"and"                                = 'and' !W
"false"                              = 'false' !W
"nil"                                = 'nil' !W
"not"                                = 'not' !W
"or"                                 = 'or' !W
"self"                               = 'self' !W
"super"                              = 'super' !W
"then"                               = 'then' !W
"true"                               = 'true' !W
"undef"                              = 'undef' !W

// formatted by $ nez format
